{"mappings":"ACAA,MAAM,EAAa,UACb,EAAc,CAClB,KACA,eACA,yBACA,uBACA,uBACA,aACA,iBACD,CAED,KAAK,gBAAgB,CAAC,UAAW,AAAA,IAC/B,EAAM,SAAS,CACb,OAAO,IAAI,CAAC,GACT,IAAI,CAAC,AAAA,GAAS,EAAM,MAAM,CAAC,IAC3B,IAAI,CAAC,IAAM,KAAK,WAAW,IAElC,GAEA,KAAK,gBAAgB,CAAC,WAAY,AAAA,IAChC,EAAM,SAAS,CACb,QAAQ,GAAG,CAAC,CACV,KAAK,OAAO,CAAC,KAAK,GAClB,OAAO,IAAI,GAAG,IAAI,CAAC,AAAA,GACV,QAAQ,GAAG,CAChB,EACG,MAAM,CAAC,AAAA,GAAa,IAAc,GAClC,GAAG,CAAC,AAAA,GAAa,OAAO,MAAM,CAAC,MAGvC,EAEL,GAEA,KAAK,gBAAgB,CAAC,QAAS,AAAA,IAE7B,IAAI,CAAA,EAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,yBAC3B,EAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,yBAC3B,EAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,oBAAA,GAK/B,GAAI,AAAuB,aAAvB,EAAM,OAAO,CAAC,IAAI,CAAiB,CACrC,EAAM,WAAW,CACf,MAAM,EAAM,OAAO,EAChB,KAAK,CAAC,IACE,OAAO,KAAK,CAAC,oBAG1B,MACF,CAGA,EAAM,WAAW,CACf,OAAO,KAAK,CAAC,EAAM,OAAO,EACvB,IAAI,CAAC,AAAA,GACJ,AAAI,GAOG,MAFc,EAAM,OAAO,CAAC,KAAK,IAGrC,IAAI,CAAC,AAAA,IAEJ,GAAI,CAAC,GAAY,AAAoB,MAApB,EAAS,MAAM,EAAY,AAAkB,UAAlB,EAAS,IAAI,CACvD,OAAO,EAGT,IAAM,EAAkB,EAAS,KAAK,GAUtC,OATA,OAAO,IAAI,CAAC,GACT,IAAI,CAAC,AAAA,IACJ,GAAI,CACF,EAAM,GAAG,CAAC,EAAM,OAAO,CAAE,EAC3B,CAAE,MAAO,EAAO,CACd,QAAQ,KAAK,CAAC,mBAAoB,EACpC,CACF,GAEK,CACT,GACC,KAAK,CAAC,AAAA,IAGL,GAFA,QAAQ,KAAK,CAAC,eAAgB,GAE1B,AAAuB,aAAvB,EAAM,OAAO,CAAC,IAAI,CACpB,OAAO,OAAO,KAAK,CAAC,iBAItB,OAAM,CACR,KAGV","sources":["<anon>","public/serviceWorker.js"],"sourcesContent":["const CACHE_NAME = 'dred-v1';\nconst urlsToCache = [\n    './',\n    './index.html',\n    './manifest.webmanifest',\n    './icons/icon-192.png',\n    './icons/icon-512.png',\n    './logo.png',\n    './offline.html'\n];\nself.addEventListener('install', (event)=>{\n    event.waitUntil(caches.open(CACHE_NAME).then((cache)=>cache.addAll(urlsToCache)).then(()=>self.skipWaiting()));\n});\nself.addEventListener('activate', (event)=>{\n    event.waitUntil(Promise.all([\n        self.clients.claim(),\n        caches.keys().then((cacheNames)=>{\n            return Promise.all(cacheNames.filter((cacheName)=>cacheName !== CACHE_NAME).map((cacheName)=>caches.delete(cacheName)));\n        })\n    ]));\n});\nself.addEventListener('fetch', (event)=>{\n    // Skip Google Analytics requests and other known problematic external services\n    if (event.request.url.includes('google-analytics.com') || event.request.url.includes('googletagmanager.com') || event.request.url.includes('overbridgenet.com')) return;\n    // Handle navigation requests\n    if (event.request.mode === 'navigate') {\n        event.respondWith(fetch(event.request).catch(()=>{\n            return caches.match('./offline.html');\n        }));\n        return;\n    }\n    // Handle other requests\n    event.respondWith(caches.match(event.request).then((response)=>{\n        if (response) return response;\n        // Clone the request - fixes the 'Failed to convert value to Response' error\n        const fetchRequest = event.request.clone();\n        return fetch(fetchRequest).then((response)=>{\n            // Don't cache if not a valid response\n            if (!response || response.status !== 200 || response.type !== 'basic') return response;\n            const responseToCache = response.clone();\n            caches.open(CACHE_NAME).then((cache)=>{\n                try {\n                    cache.put(event.request, responseToCache);\n                } catch (error) {\n                    console.error('Cache put error:', error);\n                }\n            });\n            return response;\n        }).catch((error)=>{\n            console.error('Fetch error:', error);\n            // Return offline page for navigation requests\n            if (event.request.mode === 'navigate') return caches.match('./offline.html');\n            // For other requests, just propagate the error\n            throw error;\n        });\n    }));\n});\n\n//# sourceMappingURL=serviceWorker.js.map\n","const CACHE_NAME = 'dred-v1';\nconst urlsToCache = [\n  './',\n  './index.html',\n  './manifest.webmanifest',\n  './icons/icon-192.png',\n  './icons/icon-512.png',\n  './logo.png',\n  './offline.html'\n];\n\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => cache.addAll(urlsToCache))\n      .then(() => self.skipWaiting())\n  );\n});\n\nself.addEventListener('activate', event => {\n  event.waitUntil(\n    Promise.all([\n      self.clients.claim(),\n      caches.keys().then(cacheNames => {\n        return Promise.all(\n          cacheNames\n            .filter(cacheName => cacheName !== CACHE_NAME)\n            .map(cacheName => caches.delete(cacheName))\n        );\n      })\n    ])\n  );\n});\n\nself.addEventListener('fetch', event => {\n  // Skip Google Analytics requests and other known problematic external services\n  if (event.request.url.includes('google-analytics.com') || \n      event.request.url.includes('googletagmanager.com') ||\n      event.request.url.includes('overbridgenet.com')) {\n    return;\n  }\n\n  // Handle navigation requests\n  if (event.request.mode === 'navigate') {\n    event.respondWith(\n      fetch(event.request)\n        .catch(() => {\n          return caches.match('./offline.html');\n        })\n    );\n    return;\n  }\n\n  // Handle other requests\n  event.respondWith(\n    caches.match(event.request)\n      .then(response => {\n        if (response) {\n          return response;\n        }\n\n        // Clone the request - fixes the 'Failed to convert value to Response' error\n        const fetchRequest = event.request.clone();\n\n        return fetch(fetchRequest)\n          .then(response => {\n            // Don't cache if not a valid response\n            if (!response || response.status !== 200 || response.type !== 'basic') {\n              return response;\n            }\n\n            const responseToCache = response.clone();\n            caches.open(CACHE_NAME)\n              .then(cache => {\n                try {\n                  cache.put(event.request, responseToCache);\n                } catch (error) {\n                  console.error('Cache put error:', error);\n                }\n              });\n\n            return response;\n          })\n          .catch(error => {\n            console.error('Fetch error:', error);\n            // Return offline page for navigation requests\n            if (event.request.mode === 'navigate') {\n              return caches.match('./offline.html');\n            }\n            \n            // For other requests, just propagate the error\n            throw error;\n          });\n      })\n  );\n}); "],"names":["CACHE_NAME","urlsToCache","self","addEventListener","event","waitUntil","caches","open","then","cache","addAll","skipWaiting","Promise","all","clients","claim","keys","cacheNames","filter","cacheName","map","delete","request","url","includes","mode","respondWith","fetch","catch","match","response","clone","status","type","responseToCache","put","error","console"],"version":3,"file":"serviceWorker.js.map"}