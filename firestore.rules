rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function authenticated() {
      return request.auth != null;
    }
    
    function emailVerified() {
      return request.auth.token.email_verified;
    }
    
    function ownedResource() {
      return request.auth.uid == resource.data.uid;
    }
    
    function ownedCard() {
      return request.auth.uid == resource.data.uid;
    }
    
    function isValidCard() {
      return (
        request.resource.data.type is string &&
        request.resource.data.holderName is string &&
        request.resource.data.bankName is string &&
        request.resource.data.network is string &&
        request.resource.data.expiry is string &&
        request.resource.data.encryptedCardNumber is string &&
        request.resource.data.encryptedCVV is string &&
        request.resource.data.uid is string &&
        request.resource.data.category is string &&
        request.resource.data.createdAt is timestamp
      );
    }
    
    function isWithinRateLimit(path) {
      return getCountFromTime(path, 60000) < 20;
    }

    function getCountFromTime(path, time) {
      return getCount(path, time, request.time);
    }

    function getCount(path, ms, requestTime) {
      let documents = getAfter(path, ms, requestTime);
      return documents.size();
    }

    function getAfter(path, ms, requestTime) {
      return path.where('timestamp', '>', requestTime - ms);
    }

    // Cards collection
    match /cards/{docId} {
      // Temporarily allow read/write without authentication for testing
      allow read, write: if true;
      // Original rules (commented out for now)
      // allow read: if authenticated() && ownedCard();
      // allow create: if authenticated() && request.resource.data.uid == request.auth.uid && isValidCard();
      // allow update: if authenticated() && ownedCard();
      // allow delete: if authenticated() && ownedCard();
    }

    // Transactions collection
    match /transactions/{docId} {
      // Temporarily allow read/write without authentication for testing
      allow read, write: if true;
      // Original rules (commented out for now)
      // allow read: if authenticated() && resource.data.uid == request.auth.uid;
      // allow create: if authenticated() && request.resource.data.uid == request.auth.uid;
      // allow update: if authenticated() && resource.data.uid == request.auth.uid;
      // allow delete: if authenticated() && resource.data.uid == request.auth.uid;
    }

    // Custom categories collection
    match /custom_categories/{docId} {
      allow read: if authenticated() && resource.data.uid == request.auth.uid;
      allow create: if authenticated() && request.resource.data.uid == request.auth.uid;
      allow update: if authenticated() && resource.data.uid == request.auth.uid;
      allow delete: if authenticated() && resource.data.uid == request.auth.uid;
    }

    // User settings collection
    match /user_settings/{docId} {
      allow read: if authenticated() && resource.data.uid == request.auth.uid;
      allow create: if authenticated() && request.resource.data.uid == request.auth.uid;
      allow update: if authenticated() && resource.data.uid == request.auth.uid;
      allow delete: if authenticated() && resource.data.uid == request.auth.uid;
    }

    // Validation strings collection
    match /validationStrings/{docId} {
      allow read: if authenticated() && docId == request.auth.uid;
      allow create: if authenticated() && request.resource.data.uid == request.auth.uid;
      allow update: if authenticated() && resource.data.uid == request.auth.uid;
      allow delete: if authenticated() && resource.data.uid == request.auth.uid;
    }

    match /userSecurity/{docId} {
      allow read: if authenticated() && docId == request.auth.uid;
      allow write: if authenticated() && docId == request.auth.uid;
    }

    // New rules for mobile_numbers collection
    match /mobile_numbers/{docId} {
      allow read: if authenticated() && resource.data.uid == request.auth.uid;
      allow create: if authenticated() && request.resource.data.uid == request.auth.uid;
      allow update: if authenticated() && resource.data.uid == request.auth.uid;
      allow delete: if authenticated() && resource.data.uid == request.auth.uid;
    }

    match /expenses/{docId} {
      allow read: if authenticated() && resource.data.uid == request.auth.uid;
      allow create: if authenticated() && request.resource.data.uid == request.auth.uid;
      allow update: if authenticated() && resource.data.uid == request.auth.uid;
      allow delete: if authenticated() && resource.data.uid == request.auth.uid;
    }

    // Rules for goals
    match /goals/{docId} {
      allow read: if authenticated() && resource.data.uid == request.auth.uid;
      allow create: if authenticated() && request.resource.data.uid == request.auth.uid;
      allow update: if authenticated() && resource.data.uid == request.auth.uid;
      allow delete: if authenticated() && resource.data.uid == request.auth.uid;
    }
    
    // Add rules for investment_goals collection
    match /investment_goals/{docId} {
      allow read: if authenticated() && resource.data.uid == request.auth.uid;
      allow create: if authenticated() && request.resource.data.uid == request.auth.uid;
      allow update: if authenticated() && resource.data.uid == request.auth.uid;
      allow delete: if authenticated() && resource.data.uid == request.auth.uid;
    }
  }
} 